/**
 * Annotations Service - Sync drawings/annotations to Supabase
 * 
 * Note: If the annotations table doesn't exist, operations will fail silently
 * and log warnings to console. The app will continue to work with local-only annotations.
 * 
 * The annotations table is created via migration and not generated by Supabase CLI,
 * so we need to use type assertions for database queries.
 */

import { supabase } from '@/integrations/supabase/client';

export interface AnnotationRecord {
  id: string;
  document_id: string;
  user_id: string;
  page_number: number;
  type: 'comment' | 'highlight' | 'text' | 'drawing' | 'shape';
  content: { objects?: unknown[]; version?: string } | null;
  position?: unknown;
  created_at: string;
  updated_at: string;
}

// Database client with runtime table access
// TypeScript types for 'annotations' table are defined locally since not auto-generated
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const db = supabase as any;

// Check if table exists (cached)
let tableCheckDone = false;
let tableExists = false;

async function checkTableExists(): Promise<boolean> {
  if (tableCheckDone) return tableExists;
  
  try {
    const { error } = await db.from('annotations').select('id').limit(1);
    tableExists = !error || error.code !== '42P01'; // 42P01 = table doesn't exist
    tableCheckDone = true;
    
    if (!tableExists) {
      console.warn('Annotations table does not exist. Annotations will only be stored locally.');
    }
    return tableExists;
  } catch {
    tableCheckDone = true;
    tableExists = false;
    return false;
  }
}

/**
 * Save annotations for a specific page
 */
export async function saveAnnotations(
  documentId: string,
  pageNumber: number,
  fabricObjects: any[]
): Promise<{ success: boolean; error?: string }> {
  try {
    // Check if table exists first
    if (!(await checkTableExists())) {
      return { success: false, error: 'Annotations table not available' };
    }

    // Get current user
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      return { success: false, error: 'Not authenticated' };
    }

    // Check if annotation already exists for this page
    const { data: existing, error: fetchError } = await db
      .from('annotations')
      .select('id')
      .eq('document_id', documentId)
      .eq('page_number', pageNumber)
      .eq('type', 'drawing')
      .eq('user_id', user.id)
      .maybeSingle(); // Use maybeSingle instead of single to avoid errors when no rows

    if (fetchError && fetchError.code !== 'PGRST116') {
      console.warn('Error checking existing annotation:', fetchError);
      return { success: false, error: fetchError.message };
    }

    const annotationData = {
      document_id: documentId,
      user_id: user.id,
      page_number: pageNumber,
      type: 'drawing' as const,
      content: { objects: fabricObjects, version: '5.3.0' },
      updated_at: new Date().toISOString(),
    };

    if (existing?.id) {
      // Update existing annotation
      const { error: updateError } = await db
        .from('annotations')
        .update({
          content: annotationData.content,
          updated_at: annotationData.updated_at,
        })
        .eq('id', existing.id);

      if (updateError) {
        console.warn('Error updating annotation:', updateError);
        return { success: false, error: updateError.message };
      }
    } else {
      // Insert new annotation
      const { error: insertError } = await db
        .from('annotations')
        .insert(annotationData);

      if (insertError) {
        console.warn('Error inserting annotation:', insertError);
        return { success: false, error: insertError.message };
      }
    }

    return { success: true };
  } catch (err: any) {
    console.warn('Error saving annotations:', err);
    return { success: false, error: err.message };
  }
}

/**
 * Load annotations for a document
 */
export async function loadAnnotations(
  documentId: string
): Promise<{ annotations: Map<number, unknown[]>; error?: string }> {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      return { annotations: new Map(), error: 'Not authenticated' };
    }

    const { data, error } = await db
      .from('annotations')
      .select('*')
      .eq('document_id', documentId)
      .eq('user_id', user.id)
      .eq('type', 'drawing');

    if (error) {
      console.error('Error loading annotations:', error);
      return { annotations: new Map(), error: error.message };
    }

    // Group annotations by page number
    const annotationsMap = new Map<number, unknown[]>();
    
    if (data) {
      for (const annotation of data as AnnotationRecord[]) {
        const pageNum = annotation.page_number;
        const objects = annotation.content?.objects || [];
        annotationsMap.set(pageNum, objects);
      }
    }

    return { annotations: annotationsMap };
  } catch (err: any) {
    console.error('Error loading annotations:', err);
    return { annotations: new Map(), error: err.message };
  }
}

/**
 * Delete all annotations for a page
 */
export async function clearPageAnnotations(
  documentId: string,
  pageNumber: number
): Promise<{ success: boolean; error?: string }> {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      return { success: false, error: 'Not authenticated' };
    }

    const { error } = await db
      .from('annotations')
      .delete()
      .eq('document_id', documentId)
      .eq('page_number', pageNumber)
      .eq('user_id', user.id)
      .eq('type', 'drawing');

    if (error) {
      console.error('Error deleting annotations:', error);
      return { success: false, error: error.message };
    }

    return { success: true };
  } catch (err: any) {
    console.error('Error clearing annotations:', err);
    return { success: false, error: err.message };
  }
}

/**
 * Delete all annotations for a document
 */
export async function clearDocumentAnnotations(
  documentId: string
): Promise<{ success: boolean; error?: string }> {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      return { success: false, error: 'Not authenticated' };
    }

    const { error } = await db
      .from('annotations')
      .delete()
      .eq('document_id', documentId)
      .eq('user_id', user.id);

    if (error) {
      console.error('Error deleting document annotations:', error);
      return { success: false, error: error.message };
    }

    return { success: true };
  } catch (err: any) {
    console.error('Error clearing document annotations:', err);
    return { success: false, error: err.message };
  }
}
